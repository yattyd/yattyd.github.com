<html><head>



    <style type="text/css">
/*<![CDATA[*/
#in_related_doc a { text-decoration:none; }
/*]]>*/
</style>
<link rel="Stylesheet" type="text/css" href="2006-09-16-printk_files/bdeditor.css">
<link rel="stylesheet" type="text/css" href="2006-09-16-printk_files/mods.css">

<link rel="stylesheet" type="text/css" href="2006-09-16-printk_files/e1972586da177f3e67096e3b.css">

<link rel="stylesheet" type="text/css" href="2006-09-16-printk_files/space.css">
<style type="text/css">
/*<![CDATA[*/

#usrbar{padding:4px 10px 3px 0;font-size:12px;height:19px;line-height:19px;color:#000000;font-family:Arial;text-align:right;background:#ffffff;filter:alpha(opacity=65);-moz-opacity:0.5;width:auto !important;width:100%;letter-spacing:normal}
#usrbar a,#usrbar a:link,#usrbar a:visited{color:#0000CC;text-decoration:underline}
#ft{clear:both;height:20px;line-height:20px;color:#666666;font-size:12px;font-family:Arial;text-align:center}
#ft a,#ft a:link,#ft a:visited{color:#7777CC;text-decoration:underline}
#usrbar,#usrbar a,#usrbar a:link,#usrbar a:visited,#ft,#ft a,#ft a:link,#ft a:visited{letter-spacing:normal}
/*]]>*/
</style>



<!--STATUS OK-->
<meta http-equiv="content-type" content="text/html; charset=gbk"><title>关于printk的分析（转自驱动程序开发网技术社区）_coware.com.cn: SoC Software Solutions      </title>
<style type="text/css">
.error{color:#FF0000;font-size:12px}


	


</style>
<script type="text/javascript" src="2006-09-16-printk_files/global.js"></script>
<script language="javascript" src="2006-09-16-printk_files/popup.js"></script>
<script type="text/javascript" src="2006-09-16-printk_files/BdEditor-mined.js"></script>
<script language="JavaScript" src="2006-09-16-printk_files/g_spjs.js"></script>
<script language="javascript">
<!--

var allkey="";
var i=0;
var flag=0;
function setpv(allnum)
{
	var num = allnum.split('_');
	document.getElementById("result").innerHTML=num[0];
}

function checkMail(s)
{
  	var pattern=/\w+@\w+\.[a-z]+/;
  	if(pattern.test(s))
    {
       return true;
    }
  	else
   {
      return false;
   }
}


function checkeandu(eanduid)
{
	var eanduvalue=G(eanduid).value;
	var len=bytes(eanduvalue);
	if(len>128)
	{
		showErr(2,"您输入的网址或邮箱太长，请保持在128字节以内。");
		return false;
	}
	else
	{
		 return true;
	}

}

function cmtdel(str)
{
	var pop=new Popup({ contentType:3,isReloadOnClose:false,width:340,height:80});
	pop.setContent("title","删除评论");
	pop.setContent("confirmCon","您确定要彻底删除这条评论吗？");
	pop.setContent("callBack",delCallback2);
	pop.setContent("parameter",{fid:str,popup:pop});
	pop.build();
	pop.show();
	return false;
}
function delCallback2(para)
{
	var o_pop=para["popup"];
	o_pop.config.contentType=1;
	o_pop.setContent("contentUrl","");
	o_pop.reBuild();
	G(para["fid"]).target=o_pop.iframeIdName;
	eval("document."+para["fid"]).submit();
}

String.prototype.byteLength = function() {
    return this.replace(/[^\u0000-\u007f]/g,"\u0061\u0061").length;
}

function checkname(strid)
{
	var ele=document.getElementById(strid);
	var len=bytes(ele.value);
	if(len>49)
	{
		showErr(1,"您输入的姓名太长，请保持在49字节以内。");
		return false;
	}
	else
	{
		if(len==0)
		{
			document.getElementById(strid).value="匿名网友";
		}
		 return true;
	}

}

function checktext(textid)
{
        var tempStr='';
        var isLightFont=false;
		if(editor&&textid=="spBlogCmtText"){
			//document.getElementById("spBlogCmtText").value=editor.getHtml();
			tempStr=editor.getHtml();
			tempStr=tempStr.replace(/<span style="filter:glow\(color=#([0-9a-z]{3,6}),strength=2\);height:0px;color:#([0-9a-z]{3,6})">/ig,'');
			tempStr=tempStr.replace(/<\/span>/ig,'');
			document.getElementById("spBlogCmtText").value=tempStr;
            isLightFont=!(tempStr==editor.getHtml());
        }
		document.getElementById(textid).value=trimlr(textid);
		var str=trimrn(textid);
		len=str.length;
		if(len==0 || ((/^[\s,　]+$/gi).test(str)) )
		{
			showErr(3,"您必须输入评论内容，请检查。");
			return false;
		}
		else
        {
                len=str.byteLength();
                var maxLength=isLightFont?916:1000;
				if(len > maxLength)
				{
					showErr(3,"您输入的评论内容太长，请保持在500字以内。");
					return false;
				}
				if(editor&&textid=="spBlogCmtText"){
					document.getElementById("spBlogCmtText").value=editor.getHtml();
					document.getElementById(textid).value=trimlr(textid);
				}

			return true;
		}
}

function showErr(index,str)
{
	G(index+"_err").style.display="";
	G(index+"_err_con").innerHTML=str;
}
function hidErr(index)
{
	G(index+"_err").style.display="none";
	G(index+"_err_con").innerHTML="";
}

function alertPop(tit,con)
{
	var pop=new Popup({ contentType:4,isReloadOnClose:false,width:340,height:80});
	pop.setContent("title",tit);
	pop.setContent("alertCon",con);
	pop.build();
	pop.show();
}

function cmtfull()
{
	var cnum=0;
	if(cnum>=50000)
	{
		alertPop("发表评论","单篇日志评论数最多为50000条.");
		return false;
	}
	else
	{
		return true;
	}
}

function checkcmtform()
{
	if(checkname("spBlogCmtor")&&checkeandu("spBlogCmtURL")&&checktext("spBlogCmtText")&&cmtfull())
	{
		submitForm();
		return true;
	}
	else
	{
		return false;
	}
}

var g_pop=null;
function submitForm()
{
	g_pop=new Popup({ contentType:1,isReloadOnClose:false,width:340,height:80});
	g_pop.setContent("title","添加评论");
	g_pop.setContent("contentUrl","");
	g_pop.setContent("someDisabledBtn","btn_ok");
	g_pop.build();
	G("popFormSubmit").target=g_pop.iframeIdName;
	g_pop.show();
}

function g_close_pop()
{
	g_pop.close();
}

function formatonlinpic()
{
var picobj=document.getElementsByName("onlinepic");
var picnum=picobj.length;

	for(var i=0;i<picnum;i++)
	{
		if(picobj[i].width>200)
		{
			picobj[i].width=200;
		}
		if(picobj[i].height>200)
		{
			picobj[i].height=200;
		}
	}
    try{document.getElementById("btn_ok").disabled = "";}catch(e){}
}

function addToFavor(){
var blogTitle='关于printk的分析（转自驱动程序开发网技术社区）'.replace(/&#39;/g,'\'');
window.open('http://cang.baidu.com/do/add?it='+encodeURIComponent(blogTitle+'_百度空间')+'&iu='+encodeURIComponent(location.href)+'&fr=sp#nw=1','_s','scrollbars=no,width=600,height=450,right=75,top=20,status=no,resizable=yes');
return false;
}

var isIE = /*@cc_on!@*/false;
function tracker(did,a){
	return function(){
		var t=new Date().getTime();
		var href=a.href;
        if(isIE){
            var r = /href\s*=\s*("|')?([^\s]*)\1/gi;
            if(r.test(a.outerHTML))
                href = RegExp.$2;
        }
        new Image().src = "http://hi.baidu.com/sys/statlog/1.gif?m=" + did + "&v=" + encodeURIComponent(href) + "&c=" + encodeURIComponent(location.href) + "&t="+t;
	}
}

function tracker_init(did){
	var _s=document.getElementById(did);
	var as = _s.getElementsByTagName('A');
	for(var i = 0, j = as.length; i < j; i ++){
		var a = as[i];
		if(isIE){
			a.attachEvent("onclick", tracker(did,a));
		}else{
			a.addEventListener("click", tracker(did,a), false);
		}
	}
}


/* some functions for cmt-reply */
		function cmtreply(cmtName,cmtPorID)
		{
			window.location.hash="#send";
			var cmtForm=document.form1;
			cmtForm.cm.value="3";
			if(!cmtForm.spReferTarget)
			{
				var ipt=document.createElement("input");
				ipt.type="hidden";
				ipt.name="spReferTarget";
				ipt.value=cmtPorID;
				cmtForm.appendChild(ipt);
			}else cmtForm.spReferTarget.value=cmtPorID;


			 //G("reTitle").innerHTML="回复"+cmtName+"：";
			 G("cancleReLink").style.display="";
			 cmtForm.btn_ok.value="回复评论";


			 try{
				editor.window.focus();
                editor.window.document.body.innerHTML="回复"+cmtName+"：";

                var w = editor.window;
				if(w.getSelection){
					var d = w.document;
					var s = w.getSelection();
					var r = d.createRange();
					r.setStartAfter(d.body.firstChild);
					r.setEndAfter(d.body.lastChild);
					s.removeAllRanges();
					s.addRange(r);
				}
			}catch(e){
			 		try{
				 		cmtForm.getElementsByTagName("textarea")[0].focus();
				 		cmtForm.getElementsByTagName("textarea")[0].value="回复"+cmtName+"：";
				 	}catch(e){}
			}
		}

		function canclereply()
		{
			var cmtForm=document.form1;
			cmtForm.cm.value="1";
			try{cmtForm.removeChild(cmtForm.spReferTarget);}catch(e){}
			/*
			try{
					var cmt=cmtForm.getElementsByTagName("textarea")[0]
					cmt.value="";
					cmt.focus();
			}catch(e){}
			*/

			try{
					var ed=editor.window.document.body;
					ed.innerHTML="";
					editor.window.focus();
				}catch(e){
					var cmt=cmtForm.getElementsByTagName("textarea")[0];
					cmt.value="";
					cmt.focus();
			}

			G("cancleReLink").style.display="none";
			cmtForm.btn_ok.value="发表评论";
		}

		function gotoreply()
		{//to checking whether reply cmt
			if( window.location.hash.indexOf("&re=1")<0) return;
			var cmtID=window.location.hash.split("&")[0].replace("#","");
			var cmtlinks=document.getElementsByTagName("a");
			for(var i=0,n=cmtlinks.length;i<n;i++)
			{
				if(cmtlinks[i].name==cmtID){ var rename=cmtlinks[i].getAttribute("rename");  repid=cmtlinks[i].getAttribute("repid"); break;}
			}
			if(typeof(rename)!="undefined"){
				cmtreply(rename, repid);
			}
		}

//-->
</script>

<script type="text/javascript">
    /*<![CDATA[*/

window.onerror=function(){return true;}

var RelatedDocData = null, GetAndEval = false;
(function(){
	var xhr = BdAjax.getXHR();
	if(xhr == null){
		RelatedDocData = -1;
		return;
	}

	xhr.open("GET", "/sys/search?type=8&word=%B9%D8%D3%DAprintk%B5%C4%B7%D6%CE%F6%A3%A8%D7%AA%D7%D4%C7%FD%B6%AF%B3%CC%D0%F2%BF%AA%B7%A2%CD%F8%BC%BC%CA%F5%C9%E7%C7%F8%A3%A9&item=cda52d517309dd8c8d54305e&t=" + new Date().getTime(), true);
	xhr.onreadystatechange = function(){
		if(xhr.readyState == 4){
			if(xhr.status == 0 || xhr.status == 200){
				if(GetAndEval){
					eval(xhr.responseText);
				}else{
					RelatedDocData = xhr.responseText;
				}
			}
		}
	}
	xhr.send(null);
})();
/*]]>*/
</script>

</head><body onload="formatonlinpic();"><iframe name="_BdPopupLayer_sa1nlzr3auxwzbeswdqtsx0l" style="position:absolute; z-index:65001; display:none;" id="_BdPopupLayer_sa1nlzr3auxwzbeswdqtsx0l" frameborder="0" scrolling="no"></iframe><center>
<div id="main" align="left">
<div class="stage">
<div class="stagepad">
<div style="width: 100%;">


	

<div id="m_blog" class="modbox">
<div class="tit">关于printk的分析（转自驱动程序开发网技术社区）</div>
<div class="date">2007-10-19  17:09</div>
<table style="table-layout: fixed;"><tbody><tr><td><div id="blog_text" class="cnt"><h4>LINUX下的tty,console与串口</h4>
<br>
<div class="tpc_content">公司作一个嵌入式产品，用ARM内核，LINUX操作系统（不是uclinux)。我最近的工作是把一个原来作好的模块（用串口来通信）挂到系统上，通过串口来控制该模块的一系列工作，并要求 <br>
作成单独的驱动程序（不是通过应用程序来控制）。同时也想借此熟悉LINUX下设备驱动程序的开发方法。我们买的别的公司的开发板，LINUX现在已经能
跑起来，但技术支持和文档基本没有。最近刚开始学习LINUX，算是有了一些了解，但对TTY设备、CONSOLE、串口之间的关系觉得比较混乱。这里有
几个问题请教： <br>
<br>
1、LINUX下TTY、CONSOLE、串口之间是怎样的层次关系？具体的函数接口是怎样的？串口是如何被调用的？ <br>
<br>
2、printk函数是把信息发送到控制台上吧？如何让PRINTK把信息通过串口送出？或者说系统在什么地方来决定是将信息送到显示器还是串口？ <br>
<br>
<br>
3、start_kernel中一开始就用到了printk函数（好象是printk(linux_banner什么的），在
这个时候整个内核还没跑起来呢。那这时候的printk是如何被调用的？在我们的系统中，系统启动是用的现代公司的BOOTLOADER程序，后来好象跳
到了LINUX下的head-armv.s， 然后跳到start_kernel，在bootloader
里串口已经是可用的了，那么在进入内核后是不是要重新设置？ <br>
<br>
<br>
以上问题可能问的比较乱，因为我自己脑子里也比较乱，主要还是对tty,console,serial之间的关系，特别是串口是如何被调用的没搞清。这方面的资料又比较少（就情景分析中讲了一点），希望 <br>
高手能指点一二，非常感谢！</div>
<div class="tpc_content"></div>
<div class="tpc_content">===============================================================================</div>
<div class="tpc_content">
<div class="tpc_content">看到你们的问题后，感觉很有典型性，因此花了点工夫看了一下，做了一些心得贴在这里，欢迎讨论并指正： <br>
1、LINUX下TTY、CONSOLE、串口之间是怎样的层次关系？具体的函数接口是怎样的？串口是如何被调用的？ <br>
tty和console这些概念主要是一些虚设备的概念，而串口更多的是指一个真正的设备驱动。 <br>
Tty实际是一类终端I/O设备的抽象，它实际上更多的是一个管理的概念，它和tty_ldisc（行规程）和tty_driver（真实设备驱动）组合
在一起，目的是向上层的VFS提供一个统一的接口。通过file_operations结构中的tty_ioctl可以对其进行配置。查
tty_driver，你将得到n个结果，实际都是相关芯片的驱动。因此，可以得到的结论是（实际情况比这复杂得多）：每个描述tty设备的
tty_struct在初始化时必然挂如了某个具体芯片的字符设备驱动（不一定是字符设备驱动），可以是很多，包括显卡或串口chip。不知道你的ARM
Soc是那一款，不过看情况你们应该用的是常见的chip，这些驱动实际上都有。 <br>
而console是一个缓冲的概念，它的目的有一点类似于tty。实际上console不仅和tty连在一起，还和framebuffer连在一起，具体
的原因看下面的键盘的中断处理过程。Tty的一个子集需要使用console(典型的如主设备号4，次设备号1D64)，但是要注意的是没有
console的tty是存在的。 <br>
而串口则指的是tty_driver。 <br>
举个典型的例子： <br>
分析一下键盘的中断处理过程： <br>
keyboard_interruptD&gt;handle_kbd_eventD&gt;handle_keyboard_eventD&gt;handle_scancode <br>
void handle_scancode(unsigned char scancode, int down) <br>
{ <br>
…….. <br>
tty = ttytab? ttytab[fg_console]: NULL; <br>
if (tty &amp;&amp; (!tty-&gt;driver_data)) { <br>
…………… <br>
tty = NULL; <br>
} <br>
…………. <br>
schedule_console_callback(); <br>
} <br>
这段代码中的两个地方很值得注意，也就是除了获得tty外（通过全局量tty记录），还进行了console 回显schedule_console_callback。Tty和console的关系在此已经很明了！！！ <br>
<br>
2、printk函数是把信息发送到控制台上吧？如何让PRINTK把信息通过串口送出？或者说系统在什么地方来决定是将信息送到显示器还是串口？ <br>
具体看一下printk函数的实现就知道了，printk不一定是将信息往控制台上输出，设置kernel的启动参数可能可以打到将信息送到显示器的效果。 <br>
函数前有一段英文，很有意思： <br>
/*This is printk. It can be called from any context. We want it to work. <br>
* <br>
* We try to grab the console_sem. If we succeed, it's easy - we log the output and <br>
* call the console drivers. If we fail to get the semaphore we place the output <br>
* into the log buffer and return. The current holder of the console_sem will <br>
* notice the new output in release_console_sem() and will send it to the <br>
* consoles before releasing the semaphore. <br>
* <br>
* One effect of this deferred printing is that code which calls printk() and <br>
* then changes console_loglevel may break. This is because console_loglevel <br>
* is inspected when the actual printing occurs. <br>
*/ <br>
这段英文的要点：要想对console进行操作，必须先要获得console_sem信号量。如果获得console_sem信号量，则可以“log
the output and call the console drivers”，反之，则“place the output into the
log buffer and return”，实际上，在代码： <br>
asmlinkage int printk(const char *fmt, ...) <br>
{ <br>
va_list args; <br>
unsigned long flags; <br>
int printed_len; <br>
char *p; <br>
static char printk_buf[1024]; <br>
static int log_level_unknown = 1; <br>
if (oops_in_progress) { /*如果为1情况下，必然是系统发生crush*/ <br>
/* If a crash is occurring, make sure we can't deadlock */ <br>
spin_lock_init(&amp;logbuf_lock); <br>
/* And make sure that we print immediately */ <br>
init_MUTEX(&amp;console_sem); <br>
} <br>
/* This stops the holder of console_sem just where we want him */ <br>
spin_lock_irqsave(&amp;logbuf_lock, flags); <br>
/* Emit the output into the temporary buffer */ <br>
va_start(args, fmt); <br>
printed_len = vsnprintf(printk_buf, sizeof(printk_buf), fmt, args);/*对传入的buffer进行处理，注意还不是 <br>
真正的对终端写，只是对传入的string进行格式解析*/ <br>
va_end(args); <br>
/*Copy the output into log_buf. If the caller didn't provide appropriate log level tags, we insert them here*/ <br>
/*注释很清楚*/ <br>
for (p = printk_buf; *p; p++) { <br>
if (log_level_unknown) { <br>
if (p[0] != '&lt;' || p[1] &lt; '0' || p[1] &gt; '7' || p[2] != '&gt;') { <br>
emit_log_char('&lt;'); <br>
emit_log_char(default_message_loglevel + '0'); <br>
emit_log_char('&gt;'); <br>
} <br>
log_level_unknown = 0; <br>
} <br>
emit_log_char(*p); <br>
if (*p == '\n') <br>
log_level_unknown = 1; <br>
} <br>
if (!arch_consoles_callable()) { <br>
/*On some architectures, the consoles are not usable on secondary CPUs early in the boot process.*/ <br>
spin_unlock_irqrestore(&amp;logbuf_lock, flags); <br>
goto out; <br>
} <br>
if (!down_trylock(&amp;console_sem)) { <br>
/*We own the drivers. We can drop the spinlock and let release_console_sem() print the text*/ <br>
spin_unlock_irqrestore(&amp;logbuf_lock, flags); <br>
console_may_schedule = 0; <br>
release_console_sem(); <br>
} else { <br>
/*Someone else owns the drivers. We drop the spinlock, which allows the semaphore holder to <br>
proceed and to call the console drivers with the output which we just produced.*/ <br>
spin_unlock_irqrestore(&amp;logbuf_lock, flags); <br>
} <br>
out: <br>
return printed_len; <br>
} <br>
实际上printk是将format后的string放到了一个buffer中，在适当的时候再加以show,这也回答了在start_kernel中一开始就用到了printk函数的原因 <br>
<br>
3、start_kernel中一开始就用到了printk函数（好象是printk(linux_banner什么的)，在这个时候整个内核还没跑起来
呢。那这时候的printk是如何被调用的？在我们的系统中，系统启动是用的现代公司的BOOTLOADER程序，后来好象跳到了LINUX下的
head-armv.s， 然后跳到start_kernel，在bootloader 里串口已经是可用的了，那么在进入内核后是不是要重新设置？ <br>
Bootloader一般会做一些基本的初始化，将kernel拷贝物理空间，然后再跳到kernel去执行。可以肯定的是kernel肯定要对串口进行
重新设置，原因是Bootloader有很多种，有些不一定对串口进行设置，内核不能依赖于bootloader而存在。 <br>
</div>
<div class="tpc_content">===============================================================================</div>
<div class="tpc_content">
<div class="tpc_content">多谢楼上大侠，分析的很精辟。我正在看printk函数。 <br>
<br>
我们用的CPU是hynix的hms7202。在评估板上是用串口0作 <br>
控制台，所有启动过程中的信息都是通过该串口送出的。 <br>
在bootloader中定义了函数ser_printf通过串口进行交互。 <br>
<br>
但我还是没想明白在跳转到linux内核而console和串口尚未 <br>
初始化时printk是如何能够工作的？我看了start_kernel <br>
的过程（并通过超级终端作了一些跟踪），console的初始化 <br>
是在console_init函数里，而串口的初始化实际上是在1号 <br>
进程里（init-&gt;do_basic_setup-&gt;do_initcalls-&gt;rs_init)， <br>
那么在串口没有初始化以前prink是如何工作的？特别的，在 <br>
start_kernel一开始就有printk(linux_banner)，而这时候 <br>
串口和console都尚未初始化呢。</div>
<div class="tpc_content"></div>
<div class="tpc_content">===============================================================================</div>
<div class="tpc_content"></div>
<div class="tpc_content">
<div class="tpc_content">1.在start_kernel一开始就有printk(linux_banner)，而这时候串口和console都尚未初始化? <br>
仔细分析printk可以对该问题进行解答。代码中的： <br>
/* Emit the output into the temporary buffer */ <br>
va_start(args, fmt); <br>
printed_len = vsnprintf(printk_buf, sizeof(printk_buf), fmt, args); <br>
va_end(args); <br>
将输入放到了printk_buf中，接下来的 <br>
for (p = printk_buf; *p; p++) { <br>
if (log_level_unknown) { <br>
if (p[0] != '&lt;' || p[1] &lt; '0' || p[1] &gt; '7' || p[2] != '&gt;') { <br>
emit_log_char('&lt;'); <br>
emit_log_char(default_message_loglevel + '0'); <br>
emit_log_char('&gt;'); <br>
} <br>
log_level_unknown = 0; <br>
} <br>
emit_log_char(*p); <br>
if (*p == '\n') <br>
log_level_unknown = 1; <br>
} <br>
则将printk_buf中的内容进行解析并放到全局的log_buf（在emit_log_char函数）中。 <br>
而下面的 <br>
if (!down_trylock(&amp;console_sem)) { <br>
/* <br>
* We own the drivers. We can drop the spinlock and let <br>
* release_console_sem() print the text <br>
*/ <br>
spin_unlock_irqrestore(&amp;logbuf_lock, flags); <br>
console_may_schedule = 0; <br>
release_console_sem(); <br>
} else { <br>
/* <br>
* Someone else owns the drivers. We drop the spinlock, which <br>
* allows the semaphore holder to proceed and to call the <br>
* console drivers with the output which we just produced. <br>
*/ <br>
spin_unlock_irqrestore(&amp;logbuf_lock, flags); <br>
} <br>
则是根据down_trylock(&amp;console_sem)的结果调用release_console_sem()，在release_console_sem()中才真正的对全局的log_buf中的内容相应的console设备驱动进行处理。 <br>
至此，可以得到如下的一些结论： <br>
（1）printk的主操作实际上还是针对一个buffer(log_buf),该buffer中的内容是否显示（或者说向终端输出），则要看是否可以获得console_sem。 <br>
（2）printk所在的文件为printk.c，是和体系结构无关的，因此对任何平台都一样。 <br>
可以推测的结论是： <br>
（1）kernel在初始化时将console_sem标为了locked，因此在start_kernel一开始的
printk(linux_banner)中实际只将输入写入了缓冲，等在串口和console初始化后，对printk的调用才一次将缓冲中的内容向串
口和console输出。 <br>
（2）在串口和console的初始化过程中，必然有对console_sem的up操作。 <br>
（3）因此，在embedded的调试中，如果在console的初始化之前系统出了问题，不会有任何的输出。唯一可以使用的只能是led或jtag了。 <br>
（4）因此，你的问题可以看出解答。 <br>
<br>
2.console的初始化. <br>
不知道你用的是那一个内核版本，在我看的2.4.18和2.4.19中，都是在start_kernel中就对console进行的初始化。从前面的分析来看，console的初始化不应该太晚，否则log_buf有可能溢出。 <br>
</div>
<div class="tpc_content"></div>
<div class="tpc_content">===============================================================================</div>
<div class="tpc_content"></div>
<div class="tpc_content">
<div class="tpc_content">多谢楼上，分析的很精彩！ <br>
<br>
我们用的内核版本是2.4.18，console的初始化确实是在 <br>
start_kernel-&gt;console-&gt;init。 <br>
<br>
关于tty和串口，我这里还想再问一下。tty设备的操作的总入口 <br>
是 <br>
<br>
static struct file_operations tty_fops = { <br>
llseek: no_llseek, <br>
read: tty_read, <br>
write: tty_write, <br>
poll: tty_poll, <br>
ioctl: tty_ioctl, <br>
open: tty_open, <br>
release: tty_release, <br>
fasync: tty_fasync, <br>
}; <br>
<br>
而对串口的操作定义在： <br>
<br>
static struct tty_driver serial_driver 这个结构中。 <br>
<br>
serial.c中的多数函数都是填充serial_driver中的函数指针。 <br>
<br>
那么在对串口操作时，应该是先调用tty_fops中的操作（比如 <br>
tty_open等），然后再分流到具体的串口操作（rs_open等）吧？ <br>
但tty_driver（对串口就是serial_driver)中有很多函数指针 <br>
并不跟file_operations中的函数指针对应，不知道这些对应 <br>
不上的操作是如何被执行的？比如put_char,flush_char,read_proc, <br>
write_proc,start,stop等。</div>
<div class="tpc_content"></div>
<div class="tpc_content">===============================================================================</div>
<div class="tpc_content"></div>
<div class="tpc_content">
<div class="tpc_content">以下是我对这个问题的一些理解： <br>
这实际上还是回到原先的老问题，即tty和tty_driver之间的关系。从实现上看，tty_driver实际上是tty机制的实现组件之一，借用面
向对象设计中的常用例子，这时的tty_driver就象是tty这部汽车的轮胎，tty这部汽车要正常运行，还要tty_ldisc（行规
程），termios，甚至struct tq_struct tq_hangup（看tty_struct）等基础设施。它们之间的关系并非继承。 <br>
至于tty_driver中的函数指针，再打个C++中的比喻，它们实际上很象虚函数，也就是说，可以定义它们，但并不一定实现它们。实际上还不用说
tty_driver，只要查一下serial_driver都会发现n多个具体的实现，但对各个具体的设备，其tty_driver中的函数不一定全部
实现。所以put_char,flush_char,read_proc,
write_proc,start,stop这些函数的情况是有可能实现，也有可能不实现。即使被实现，也不一定为上层(VFS层)所用。 <br>
</div>
</div>
</div>
</div>
</div>
</div></div></td></tr></tbody></table>
</div>




</div>
</div>

</div>

</div>
</center>
</body></html>